* Multisig Wallet

This is demonstration of an M of N wallet, where there are N private keys and it takes signatures
from M of the N participants to release the funds. See [[https://en.bitcoin.it/wiki/Multisignature][bitcoin's version]].

* Requirements

Python version 3.7 is required. See https://www.python.org/downloads/ or use a package
manager for your OS to install it. On Mac OS X, consider [[https://brew.sh/][brew]].

* Set up

First, create a virtualenv. There are many ways to do this. Here is one.

#+BEGIN_SRC bash
  $ python3 -m venv env
  $ ln -s env/bin/activate
  $ . ./activate
  $ pip install -r requirements.txt
  $ pip install -e .
#+END_SRC

* Create the N private wallets

For our example, we will use M=2, N=4.

Do the following:

#+BEGIN_SRC bash
  $ python -m multisig.signer
  wallet name> anna
  public hd key is 00000001000000000000000000b09562cb56fa84e0040cc53213af65b4d2e8e2eef1327694cc8a4c766c76a9de160607f5bd0b4111a55c63dcaa62050653b4c3e76f767bf3b93cb7c6fffbc43ff5c65b2252cf5a6ab651d2b4a38fa839
enter partially-signed transaction hex>
#+END_SRC

Note that if the wallet does not exist, it's created and written to ~private.anna.json~. Subsequent
attempts to start using wallet name ~anna~ will reload this wallet.

The hd key is generated using OS level randomness (~os.urandom~), so the key generated by your
machine will very probably be different.

Enter a blank line to exit when prompted for a partially-signed transaction to exit.

Now create three more wallets with names ~bob~, ~carry~ and ~doug~. Or make up your own names.
Or use numbers. Whatever you want.

We see our hierarchical deterministic (hd) wallet public key.

* Create the multisig wallet

A central facilitator collects the public hd keys from the N participants, and creates the
multisig wallet. Do the following:


#+BEGIN_SRC bash
  $ python -m multisig.wallet
  Creating M of N wallet
  Enter a public hd key> 
#+END_SRC

Now enter the four hd keys you created above. Obviously they're too long to accurately
retype, so use copy and paste.

Enter a blank line after the fourth key. Then set M to 2.

Now you'll see the main menu. Subsequent runs will notice the existence of the file
~multisig-wallet.json~ and skip the creation step. Exit using choice ~0~ and run it again
to check.

* Generate an address

Try this yourself.

#+BEGIN_SRC bash
$ python -m multisig.wallet
Choose:
0. Quit
1. Generate an address
2. Spend a coin
> 1
Choose index (integer >= 0)> 0
address #0 is d08c415c85c2e8873f9c085a73f252897bf23d6efea08ba90284fba839e974ea
Here is a sample coin with that address:
0000000000000000000000000000000000000000000000000000000000000001d08c415c85c2e8873f9c085a73f252897bf23d6efea08ba90284fba839e974ea000000003b9aca00
Choose:
0. Quit
1. Generate an address
2. Spend a coin
> 0
#+END_SRC

Obviously, the address you generate will not match the above.

A sample coin locked via the generated address is also "created". You can use it in step 2.

* Spend the coin

** Generate the Unfinished Spend

Choose option 2. The destination address is preselected, as this is demonstration is more
about the process of generating and aggregating the signatures rather than creating smart
destinations.

Copy and paste a sample coin. You can enter multiple coins as inputs, but for now, try just
one coin by entering a blank line for the second coin.

You will see a huge blob of hex. This is the unfinished spend.

** Sign the Unfinished Spend

This hex blob must be sent to M different signers, who will 

Open another window, and without exiting the multisig wallet, relaunch

#+BEGIN_SRC bash
$ source activate
$ python -m multisig.signer
wallet name> anna
public hd key is 00000001000000000000000000b09562cb56fa84e0040cc53213af65b4d2e8e2eef1327694cc8a4c766c76a9de160607f5bd0b4111a55c63dcaa62050653b4c3e76f767bf3b93cb7c6fffbc43ff5c65b2252cf5a6ab651d2b4a38fa839
enter partially-signed transaction hex>
#+END_SRC

Now copy and paste the large blob and hit return.

Eventually the signing program should also display some information about exactly what it's
signing so the user can examine it for correctness before approving that it be signed.
This step is currently skipped.

The signing program will analyze the blob and generate whatever signatures is can, one per line.

** Copy the Signature to Wallet

The signer would then transmit the signature to the central coordinator. In this demo, that means
copy and paste the signature. You will see a message similar to

~coin cf55bad003a4894b4027901edac2137870ce6405f1aaff568d4521b1638e49a0 has 1 of 2 sigs~

Now repeat the procedure with another wallet like ~bob~. Once you copy and paste this signature,
you will see another large blob called the "spend". This is a finalized transaction that will
correctly validate.
